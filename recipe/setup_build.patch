diff --git a/orig/setup_build.py b/mod/setup_build.py
index 3eba78e..228544b 100644
--- a/orig/setup_build.py
+++ b/mod/setup_build.py
@@ -1,8 +1,7 @@
 import io
 import os
+import re
 from os.path import join
-import sys
-import textwrap
 
 from distutils.log import info
 from setuptools import Extension
@@ -25,47 +24,38 @@ def write_pxi(filename, definitions):
     return filename
 
 
-def check_macro_true(cmd, symbol, headers=None, include_dirs=None):
-    """
-    Copied from numpy.distutils.command.config:config.check_macro_true, checks
-    if macro is true
-    """
-    cmd._check_compiler()
-    body = textwrap.dedent("""
-        int main(void)
-        {
-        #if %s
-        #else
-        #error false or undefined macro
-        #endif
-            ;
-            return 0;
-        }""") % (symbol,)
-
-    return cmd.try_compile(body, headers, include_dirs)
-
-
-def check_macro_def(cmd, symbol, headers=None, include_dirs=None):
-    """
-    Based on numpy.distutils.command.config:config.check_macro_true, checks if
-    macro is defined or not
-    """
-    cmd._check_compiler()
-    body = textwrap.dedent("""
-        int main(void)
-        {
-        #ifdef %s
-        #else
-        #error undefined macro
-        #endif
-            ;
-            return 0;
-        }""") % (symbol,)
-
-    return cmd.try_compile(body, headers, include_dirs)
-
-
-def get_sundials_config_pxi(include_dirs, dist):
+def parse_macros(header_file_path):
+
+    # Read the header file and store the macro names and values in a dict
+    macros = {}
+
+    # Regular expression to match macro definitions
+    macro_pattern = re.compile(r'#define\s+(\w+)\s+(.*)')
+
+    with open(header_file_path, 'r') as file:
+        for line in file:
+            match = macro_pattern.match(line)
+            if match:
+                macro_name = match.group(1)
+                macro_value = match.group(2)
+                macros[macro_name] = macro_value
+
+    return macros
+
+
+def check_macro_true(macros, symbol):
+
+    value = macros.get(symbol)
+
+    return bool(value)
+
+
+def check_macro_def(macros, symbol):
+
+    return symbol in macros.keys()
+
+
+def get_sundials_config_pxi(SUNDIALS_INCLUDE_DIRS):
     """
     Create pxi file containing some of sundials build config
 
@@ -73,72 +63,57 @@ def get_sundials_config_pxi(include_dirs, dist):
     distutils/numpy not setting _setup_distribution at the right time or
     something...
     """
-    SUNDIALS_CONFIG_H = "sundials/sundials_config.h"
-    BASE_PATH = 'src/scikits_odes_sundials'
 
-    config_cmd = dist.get_command_obj("config")
+    for directory in SUNDIALS_INCLUDE_DIRS:
+        if os.path.exists(directory + '/sundials/sundials_config.h'):
+            SUNDIALS_CONFIG_H = directory + '/sundials/sundials_config.h'
+
+            macros = parse_macros(SUNDIALS_CONFIG_H)
+
+        else:
+            macros = {}
+
+    BASE_PATH = 'src/scikits_odes_sundials'
 
     # Get float type
-    if check_macro_true(
-        config_cmd,
-        "SUNDIALS_DOUBLE_PRECISION", headers=[SUNDIALS_CONFIG_H],
-        include_dirs=include_dirs
-    ):
+    if check_macro_true(macros, "SUNDIALS_DOUBLE_PRECISION"):
         SUNDIALS_FLOAT_TYPE = '"double"'
-        info("Found sundials built with double precision.")
-    elif check_macro_true(
-        config_cmd,
-        "SUNDIALS_SINGLE_PRECISION", headers=[SUNDIALS_CONFIG_H],
-        include_dirs=include_dirs
-    ):
+        info("\n\nFound sundials built with double precision.\n\n")
+    elif check_macro_true(macros, "SUNDIALS_SINGLE_PRECISION"):
         SUNDIALS_FLOAT_TYPE = '"single"'
-        info("Found sundials built with single precision.")
-    elif check_macro_true(
-        config_cmd,
-        "SUNDIALS_EXTENDED_PRECISION", headers=[SUNDIALS_CONFIG_H],
-        include_dirs=include_dirs
-    ):
+        info("\n\nFound sundials built with single precision.\n\n")
+    elif check_macro_true(macros, "SUNDIALS_EXTENDED_PRECISION"):
         SUNDIALS_FLOAT_TYPE = '"extended"'
-        info("Found sundials built with extended precision.")
+        info("\n\nFound sundials built with extended precision.\n\n")
     else:
         # fall back to double
         SUNDIALS_FLOAT_TYPE = '"double"'
-        info("Failed to find sundials precision, falling back to double...")
+        info("\n\nFailed to find sundials precision, falling back to double.\n\n")
 
     # Get index (int) type
-    if check_macro_true(
-        config_cmd,
-        "SUNDIALS_INT32_T", headers=[SUNDIALS_CONFIG_H],
-        include_dirs=include_dirs
-    ):
+    if check_macro_true(macros, "SUNDIALS_INT32_T"):
         SUNDIALS_INDEX_SIZE = '"int32"'
-        info("Found sundials built with int32.")
-    elif check_macro_true(
-        config_cmd,
-        "SUNDIALS_INT64_T", headers=[SUNDIALS_CONFIG_H],
-        include_dirs=include_dirs
-    ):
+        info("\n\nFound sundials built with int32.\n\n")
+    elif check_macro_true(macros, "SUNDIALS_INT64_T"):
         SUNDIALS_INDEX_SIZE = '"64"'
-        info("Found sundials built with int64.")
+        info("\n\nFound sundials built with int64.\n\n")
     else:
         # fall back to int64
         SUNDIALS_INDEX_SIZE = '"64"'
-        info("Failed to find sundials index type, falling back to int64...")
+        info("\n\nFailed to find sundials index type, falling back to int64.\n\n")
 
     # Check for blas/lapack
-    if check_macro_def(
-        config_cmd,
-        "SUNDIALS_BLAS_LAPACK", headers=[SUNDIALS_CONFIG_H],
-        include_dirs=include_dirs
-    ):
+    if check_macro_def(macros, "SUNDIALS_BLAS_LAPACK_ENABLED"):
         has_lapack = True
+        info("\n\nFound BLAS/LAPACK enabled. Setting has_lapack=True.\n\n")
     else:
         has_lapack = False
+        info("\n\nFailed to find BLAS/LAPACK enabled. Setting has_lapack=False.\n\n")
 
     cfg = dict(
-        float_type = SUNDIALS_FLOAT_TYPE,
-        index_size = SUNDIALS_INDEX_SIZE,
-        has_lapack = has_lapack,
+        float_type=SUNDIALS_FLOAT_TYPE,
+        index_size=SUNDIALS_INDEX_SIZE,
+        has_lapack=has_lapack,
     )
 
     return write_pxi(join(BASE_PATH, "sundials_config.pxi"), dict(
@@ -153,6 +128,7 @@ class build_ext(_build_ext):
         Custom distutils command which encapsulates api_gen pre-building,
         Cython building, and C compilation.
     """
+
     def _get_cython_ext(self):
         import numpy
         base_path = 'src/scikits_odes_sundials'
@@ -190,8 +166,10 @@ class build_ext(_build_ext):
             )
 
         elif SUNDIALS_INST_PREFIX is not None:
-            SUNDIALS_LIBRARY_DIRS.append(os.path.join(SUNDIALS_INST_PREFIX, "lib"))
-            SUNDIALS_INCLUDE_DIRS.append(os.path.join(SUNDIALS_INST_PREFIX, "include"))
+            SUNDIALS_LIBRARY_DIRS.append(
+                os.path.join(SUNDIALS_INST_PREFIX, "lib"))
+            SUNDIALS_INCLUDE_DIRS.append(
+                os.path.join(SUNDIALS_INST_PREFIX, "include"))
             info("SUNDIALS installation path set to `{}` via $SUNDIALS_INST.".format(
                 SUNDIALS_INST_PREFIX))
         else:
@@ -218,7 +196,6 @@ class build_ext(_build_ext):
                     for lib in ida_pkgconf.get('include_dirs', []):
                         IDA_LIBRARIES.append(str(lib))
 
-
                     cvodes_pkgconf = pkgconfig.parse(PKGCONFIG_CVODES)
                     for d in cvodes_pkgconf.get('library_dirs', []):
                         CVODES_LIBRARY_DIRS.append(str(d))
@@ -239,8 +216,7 @@ class build_ext(_build_ext):
             except ImportError:
                 info("pkgconfig module not found, using preset paths")
 
-        sundials_pxi, cfg = get_sundials_config_pxi(SUNDIALS_INCLUDE_DIRS,
-                self.distribution)
+        sundials_pxi, cfg = get_sundials_config_pxi(SUNDIALS_INCLUDE_DIRS)
 
         has_lapack = cfg['has_lapack']
 
@@ -302,42 +278,41 @@ class build_ext(_build_ext):
         return [
             Extension(
                 base_module + '.' + "common_defs",
-                sources = [join(base_path, 'common_defs.pyx')],
+                sources=[join(base_path, 'common_defs.pyx')],
                 include_dirs=SUNDIALS_INCLUDE_DIRS,
                 library_dirs=SUNDIALS_LIBRARY_DIRS,
                 libraries=SUNDIALS_LIBRARIES,
             ),
             Extension(
                 base_module + '.' + "cvode",
-                sources = [join(base_path, 'cvode.pyx')],
+                sources=[join(base_path, 'cvode.pyx')],
                 include_dirs=CVODE_INCLUDE_DIRS,
                 library_dirs=CVODE_LIBRARY_DIRS,
                 libraries=CVODE_LIBRARIES,
             ),
             Extension(
                 base_module + '.' + "ida",
-                sources = [join(base_path, 'ida.pyx')],
+                sources=[join(base_path, 'ida.pyx')],
                 include_dirs=IDA_INCLUDE_DIRS,
                 library_dirs=IDA_LIBRARY_DIRS,
                 libraries=IDA_LIBRARIES,
             ),
             Extension(
                 base_module + '.' + "cvodes",
-                sources = [join(base_path, 'cvodes.pyx')],
+                sources=[join(base_path, 'cvodes.pyx')],
                 include_dirs=CVODES_INCLUDE_DIRS,
                 library_dirs=CVODES_LIBRARY_DIRS,
                 libraries=CVODES_LIBRARIES,
             ),
             Extension(
                 base_module + '.' + "idas",
-                sources = [join(base_path, 'idas.pyx')],
+                sources=[join(base_path, 'idas.pyx')],
                 include_dirs=IDAS_INCLUDE_DIRS,
                 library_dirs=IDAS_LIBRARY_DIRS,
                 libraries=IDAS_LIBRARIES,
             ),
         ]
 
-
     def run(self):
         """ Distutils calls this method to run the command """
         from Cython.Build import cythonize
@@ -347,5 +322,4 @@ class build_ext(_build_ext):
                 'language_level': 3,
             },
         )
-        _build_ext.run(self) # actually do the build
-
+        _build_ext.run(self)  # actually do the build
